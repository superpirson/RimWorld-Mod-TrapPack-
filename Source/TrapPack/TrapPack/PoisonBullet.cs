// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
//using System.Threading.Tasks;
using UnityEngine;
using Verse.Sound;
using Verse;
using RimWorld;
namespace TrapPack
{
	public class PoisonBullet :Bullet
	{
		protected override void Impact (Thing hitThing)
		{
			base.Impact (hitThing);
			if (hitThing != null)
			{
				Poisoning found_p = null;
				if ( hitThing.attachments != null){
				 found_p =hitThing.attachments.Find((AttachableThing thing) => (thing is Poisoning)) as Poisoning;
				}
				// use puddle as our e-type
				if (found_p != null)
				{
					found_p.quantity += this.def.projectile.damageAmountBase;
					return;
				}
				else if (hitThing is Pawn){
					Poisoning poisoning = new Poisoning(hitThing as Pawn, this.def.projectile.damageAmountBase, this.def.projectile.damageAmountBase);
					poisoning.AttachTo (hitThing);
				}
			}
			else
			{
			
			}
			MoteMaker.ThrowFlash (base.Position, "ShotFlash", 6f);
			MoteMaker.TryThrowMicroSparks (base.Position.ToVector3Shifted ());
		}
	
	
	}
	
	
	// code taken from ty's fire code
	public class Poisoning : AttachableThing
	{
		private static DamageTypeDef poisoned_damage = (DamageTypeDef)DefDatabase<DamageTypeDef>.GetNamed("Poisoned");
		private static DamageTypeDef antidote_damage = (DamageTypeDef)DefDatabase<DamageTypeDef>.GetNamed("Antidote");
		public int potency = 100;
		public int quantity = 100;
		public List<BodyDefPart> body_parts = new List<BodyDefPart>();
		public Pawn attached_pawn;
		public int ticksSinceDamage = 0;
		
		public Poisoning(Pawn attached_pawn, int potency, int quantity){
			this.attached_pawn = attached_pawn;
			this.potency = potency;
							this.quantity = quantity;
		}
		public override string InfoStringAddon
		{
			get
			{
				return "Poisoned. Potency: " + this.potency.ToString();
			}
		}
		
		public override string Label
		{
			get
			{
				if (this.parent != null)
				{
					return "Poisening on: " +this.parent.Label;
				}
				return "Poisening";
			}
		}
		
		private float TicksBeforeDamage
		{
			get
			{
				return 80f * 1f/(float)this.potency;
			}
		}
		//
		// Methods
		//
		protected override void ApplyDamage (DamageInfo d)
		{
			if (d.Def ==antidote_damage)
			{
				this.potency -= d.Amount ;
				if (this.potency <= 0)
				{
					this.Destroy (DestroyMode.Vanish);
					return;
				}
			}
			}
		public override void Draw ()
		{
		/*
			float num = this.fireSize / 1.2f;
			if (num > 1.2f)
			{
				num = 1.2f;
			}
			Vector3 s = new Vector3 (num, 1f, num);
			Matrix4x4 matrix = default(Matrix4x4);
			matrix.SetTRS (this.DrawPos, this.rotation.AsQuat, s);
			Graphics.DrawMesh (MeshPool.plane10, matrix, this.DrawMat (this.rotation), 0);
			*/
		}
		
		public override Material DrawMat (IntRot rot)
		{
			return BaseContent.BadMat;
		}
		
		public override void ExposeData ()
		{
			base.ExposeData ();
			Scribe_Values.LookValue<int> (ref this.potency, "potency", 0,false);
			Scribe_Values.LookValue<int> (ref this.quantity, "quantity", 0,false);
			Scribe_Values.LookValue<Pawn> (ref this.attached_pawn, "attached_pawn", null,false);
			Scribe_Values.LookValue<List<BodyDefPart>> (ref this.body_parts, "body_parts", null,false);
		}
		
		public override void SpawnSetup ()
		{
			base.SpawnSetup ();
			/*
			this.RecalcPathsOnAndAroundMe ();
			Find.ConceptTracker.TeachOpportunity (ConceptDefOf.HomeRegion, this, OpportunityType.Important);
			SoundInfo info = SoundInfo.InWorld (this, MaintenanceType.PerTick);
			this.sustainer = SustainerAggregatorUtility.AggregateOrSpawnSustainerFor (this, Fire.BurningSoundDef, info);
			*/
		}
		
		public override void Tick ()
		{
			//this.sustainer.Maintain ();
			this.ticksSinceDamage++;
			if ((float)this.ticksSinceDamage >= this.TicksBeforeDamage)
			{
				if (this.parent == null)
				{
					Log.Warning("poisening's parent is null, destroying self");
					this.Destroy();
				}
				// do the actual damage to the pawn
				if (body_parts.Count > 0){
					attached_pawn.TakeDamage (new DamageInfo (poisoned_damage, potency / 5, this, new BodyPartDamageInfo(body_parts.RandomElement(), false), this.def));
				}
				if (this.quantity > 80)
				{
					//attached_pawn.healthTracker.bodyModel.GetRandomNotMissingPart()
					BodyDefPart new_part = body_parts.RandomElement().parent;
					if (new_part != null){
						body_parts.Add(new_part);
						this.quantity -= new_part.def.health / 4;
					}
				}
				this.ticksSinceDamage = 0;
			}
		}
	}
}

